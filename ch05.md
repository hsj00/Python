# CH05

## 05-1. Class

### Class?

- 클래스(Class): 객체들이 공동적으로 갖는 속성들을 모아서 정의내린 것
- 객체:클래스 = 붕어빵:붕어빵틀
- 공통 속성을 갖는 객체들의 수가 늘어날수록 클래스를 이용해 반복 작업을 덜 수 있다

```python
# 2대의 계산기가 필요하여 함수 2개를 구현한 경우

result1 = 0
result2 = 0

def add1(num):
    global result1
    result1 += num
    return result1

def add2(num):
    global result2
    result2 += num
    return result2

print(add1(3))
print(add1(4))
print(add2(3))
print(add2(7))
```

```python
# Class 예제
# 함수를 2개 사용했을 때와 동일한 결과 출력

class Calculator:               # Calaulator 클래스 선언
    def __init__(self):         # initiating (self)
        self.result = 0
    
    def add(self, num):
        self.result += num
        return self.result

cal1 = Calculator()             # Calculator 클래스로 만든 별개의 계산기 객체 1
cal2 = Calculator()             # Calculator 클래스로 만든 별개의 계산기 객체 2

print(cal1.add(3))
print(cal1.add(4))
print(cal2.add(3))
print(cal2.add(7))
```
``` python
def sub(self, num):
    self.result -= num
    return self.result
```

### Class/Object

- 붕어빵틀 -> 클래스(Class) / 붕어빵 -> 객체(Object)
- 클래스는 일종의 설계도면 역할을 한다
- 클래스로 만든 객체는 각각의 고유한 성격을 갖는다
- 동일한 클래스로 만든 객체간에 영향을 주지 않는다
- 클래스로 만든 객체를 인스턴스라고도 함
  - 특정 개체가 어떤 클라스의 객체인지 관계 위주로 설명할 때 사용
  - ex) "a는 객체", "a는 Cookie의 인스턴스"

```python
# 아무 기능이 없는 Class로 객체 생성하는 예제
class Cookie:
    pass            # pass는 아무것도 수행하지 않는 문법, 임시 코드를 작성할 때 주로 사용

# Cookie()의 결과값을 돌려받는 객체 a, b
a = Cookie()    
b = Cookie()
```

### 4칙연산 클래스 만들기 (+ 나머지 구하기 기능 추가)

#### 클래스 구상

  1. `a = FourCal()` 객체 생성
  2. `a.setdata(a, b)`처럼 객체에 숫자를 지정
  3. `a.add()`, `a.mul()`, `a.sub()`, `a.div()`, `a.divR()` 총 4+1가지 구현

```python
class FourCal:
    # 클래스 안에 구현된 함수, 메서드(Method)
    # 객체에 숫자 지정하는 메서드
    def setdata(self, first, second):   # 메서드의 매개변수
        self.first = first              # 메서드의 수행문1
        self.second = second            # 메서드의 수행문2

    # 연산 기능 메서드
    def add(self):                      # 더하기
        result = self.first + self.second
        return result
    
    def sub(self):                      # 빼기
        result = self.first - self.second
        return result

    def mul(self):                      # 곱하기
        result = self.first * self.second
        return result

    def div(self):                      # 나누기
        result = self.first / self.second
        return result

    def divR(self):                     # 나머지    
        result = self.first % self.second
        return result
```
![메서드 배개변수 호출](./ch05_pic/ch05_setdata.png)

```python
>>> a = FourCal()
>>> FourCal.setdata(a, 4, 2)

>>> a = Fourcal()
>>> a.setdata(4, 2)
```

- `클래스 이름.메서드` 형태로 호출할 때, 객체 a를 첫 번째 매개변수에 꼭 전달해야 함
- `객체.메서드` 형태로 호출할 때, self에 전달되는 인수는 생략

### 생성자 (Constructor)

- 객체가 생성될 때 자동으로 호출되는 메서드
- `setdata()` 메서드를 수행하지 않아 객체 `a`의 객체변수 `first`, `second`가 생성되지 않음
- 메서드를 호출하여 초기값을 설정하는 것보다 생성자를 구현하는 것이 안전함
- 메서드 이름으로 `__init__`을 사용하면 이 메서드는 생성자가 된다

```python
# example
>>> a = FourCal()
>>> a.add()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 6, in add
AttributeError: 'FourCal' object has no attribute 'first'
```

```python
# 생성자(Constructor) 예제
class FourCal:
    # 생성자를 사용하는 메서드
    def __init__(self, first, second):
        self.first = first              # 메서드의 수행문1
        self.second = second            # 메서드의 수행문2
.
.
.
```

- `__init__` 메서드는 `setdata`와 이름만 다르고 모든게 동일
- 메서드 이름을 `__init__`으로 했기 때문에 생성자로 인식되어 객체 생성 시점에 자동으로 호출되는 차이가 있음
- `a = FourCal()` 수행시 생성자 `__init__`이 호출되어 오류 발생 (매개변수 `first`와 `second`에 해당되는 값이 전달되지 않음)

```python
>>> a = FourCal()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: __init__() missing 2 required positional arguments: 'first' and 'second'
```
```python
>>> a = FourCal(4, 2)
>>>
```

### 클래스의 상속 (inheritance)